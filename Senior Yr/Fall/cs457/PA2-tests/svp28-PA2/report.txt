vector<Move> Astar::Astar_search(){
	root.g = 0;
	root.h = heuristic(&root);

	opened.push(root);

	while(!opened.empty()){
		
		Node n = opened.top();
	
		opened.pop();

		if(goalTest(&n)){
			cout << "goal reached!" << endl;
			return printPath(&n);
			
		}
		vector<Node>::iterator it = closed.begin();
		closed.push_back(n);
		
		vector<Move> allMoves = n.state.calculateMoves();

		for(int moveInx=0; moveInx < allMoves.size(); moveInx++){
			Node newChild(n);

			newChild.g = n.g + 1;
			newChild.depth = n.depth + 1;
			newChild.move = allMoves[moveInx];
			newChild.parent = &n;

			newChild.addMove(allMoves[moveInx]);
			//clock_t begin = clock();
			newChild.state = n.state.applyMoveSeparate(allMoves[moveInx]);
			newChild.hash = newChild.state.computeHash();

			newChild.h = heuristic(&newChild);
			
			if( (!checkIfClosed(&newChild)) ){
				n.addChild(newChild);
				opened.push(newChild);
			}
		}
	


	}
}